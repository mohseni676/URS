/*
 * This file is part of OWLDB.
 * 
 * OWLDB is free software: you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any
 * later version.
 * 
 * OWLDB is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with OWLDB. If not, see <http://www.gnu.org/licenses/>.
 */

package owldb;

import java.io.*;
import java.net.*;
import java.util.*;
import java.util.logging.*;
import org.semanticweb.owlapi.io.*;
import org.semanticweb.owlapi.model.*;
import org.semanticweb.owlapi.util.*;


/**
 * DB Modification. This Class is based on the OWLOntologyManagerImpl written by
 * Matthew Horridge.
 * 
 * @author J&ouml;rg Hen&szlig; (KIT)
 * @author J&uuml;rgen Mo&szlig;graber (Fraunhofer IOSB)
 * @author Yongchun Xu (FZI)
 */
public class OWLDBOntologyManager implements OWLOntologyManager, OWLOntologyFactory.OWLOntologyCreationHandler
{
	static final Logger																																						LOGGER											= Logger.getLogger (OWLDBOntologyManager.class.getName ());

	private final Map<OWLOntologyID, OWLOntology>																									ontologiesByID;
	private final Map<OWLOntologyID, IRI>																													irisByID;
	private final Map<OWLOntology, OWLOntologyFormat>																							ontologyFormatsByOntology;
	private final Map<OWLImportsDeclaration, OWLOntologyID>																				ontologyIDsByImportsDeclaration;
	private final List<OWLOntologyIRIMapper>																											documentMappers;
	private final List<OWLOntologyFactory>																												ontologyFactories;
	private final List<OWLOntologyStorer>																													ontologyStorers;
	private boolean																																								broadcastChanges;
	private int																																										loadCount										= 0;
	private int																																										importsLoadCount						= 0;
	private boolean																																								silentMissingImportsHandling;
	private final OWLDataFactory																																	dataFactory;
	private final Map<OWLOntology, Set<OWLOntology>>																							importsClosureCache;
	private final OWLOntologyManagerProperties																										properties;
	private final List<MissingImportListener>																											missingImportsListeners;
	private final List<OWLOntologyLoaderListener>																									loaderListeners;
	private final List<OWLOntologyChangeProgressListener>																					progressListeners;
	private Map<ImpendingOWLOntologyChangeListener, ImpendingOWLOntologyChangeBroadcastStrategy>	impendingChangeListenerMap	= new IdentityHashMap<ImpendingOWLOntologyChangeListener, ImpendingOWLOntologyChangeBroadcastStrategy> ();
	private List<OWLOntologyChangesVetoedListener>																								vetoListeners								= new ArrayList<OWLOntologyChangesVetoedListener> ();
	private int																																										autoGeneratedURICounter;
	private OWLOntologyChangeBroadcastStrategy																										defaultChangeBroadcastStrategy;
	private ImpendingOWLOntologyChangeBroadcastStrategy																						defaultImpendingChangeBroadcastStrategy;


	/**
	 * Constructor.
	 * 
	 * @param dataFactory The data factory
	 */
	public OWLDBOntologyManager (final OWLDataFactory dataFactory)
	{
		this.dataFactory = dataFactory;
		this.properties = new OWLOntologyManagerProperties ();
		this.ontologiesByID = new HashMap<OWLOntologyID, OWLOntology> ();
		this.irisByID = new HashMap<OWLOntologyID, IRI> ();
		this.ontologyFormatsByOntology = new HashMap<OWLOntology, OWLOntologyFormat> ();
		this.documentMappers = new ArrayList<OWLOntologyIRIMapper> ();
		this.ontologyFactories = new ArrayList<OWLOntologyFactory> ();
		this.ontologyIDsByImportsDeclaration = new HashMap<OWLImportsDeclaration, OWLOntologyID> ();
		this.installDefaultURIMappers ();
		this.installDefaultOntologyFactories ();
		this.broadcastChanges = true;
		this.ontologyStorers = new ArrayList<OWLOntologyStorer> ();
		this.importsClosureCache = new HashMap<OWLOntology, Set<OWLOntology>> ();
		this.missingImportsListeners = new ArrayList<MissingImportListener> ();
		this.loaderListeners = new ArrayList<OWLOntologyLoaderListener> ();
		this.progressListeners = new ArrayList<OWLOntologyChangeProgressListener> ();
		this.autoGeneratedURICounter = 0;
		this.defaultChangeBroadcastStrategy = new DefaultChangeBroadcastStrategy ();
		this.defaultImpendingChangeBroadcastStrategy = new DefaultImpendingChangeBroadcastStrategy ();
	}


	/**
	 * Get the properties of owl ontology manager.
	 * 
	 * @return The properties
	 */
	public OWLOntologyManagerProperties getProperties ()
	{
		return this.properties;
	}


	/** {@inheritDoc} */
	@Override
	public Collection<OWLOntologyFactory> getOntologyFactories ()
	{
		return new ArrayList<OWLOntologyFactory> (this.ontologyFactories);
	}


	/** {@inheritDoc} */
	@Override
	public OWLDataFactory getOWLDataFactory ()
	{
		return this.dataFactory;
	}


	/** {@inheritDoc} */
	@Override
	public Set<OWLOntology> getOntologies ()
	{
		return new HashSet<OWLOntology> (this.ontologiesByID.values ());
	}


	/** {@inheritDoc} */
	@Override
	public Set<OWLOntology> getOntologies (final OWLAxiom axiom)
	{
		final Set<OWLOntology> result = new HashSet<OWLOntology> (this.ontologiesByID.size ());
		for (final OWLOntology ont: this.getOntologies ())
		{
			if (ont.containsAxiom (axiom))
				result.add (ont);
		}
		return result;
	}


	/**
	 * Test if the input ontology is in the current ontology manager.
	 * 
	 * @param ontology The ontology for which to checl
	 * @return Return <code> true</code> if the ontology is in manager, else
	 *         return <code>false</code>
	 */
	public boolean contains (final OWLOntology ontology)
	{
		return this.ontologiesByID.containsValue (ontology);
	}


	/** {@inheritDoc} */
	@Override
	public boolean contains (final IRI ontologyIRI)
	{
		return this.contains (new OWLOntologyID (ontologyIRI));
	}


	/** {@inheritDoc} */
	@Override
	public boolean contains (final OWLOntologyID id)
	{
		return this.ontologiesByID.containsKey (id);
	}


	/**
	 * Gets a previously loaded/created ontology that has the specified ontology
	 * IRI and no version IRI.
	 * 
	 * @param ontologyIRI The IRI of the ontology to be retrieved.
	 * @return The ontology that has the specified IRI and no version IRI, or
	 *         <code>null</code> if this manager does not manage an ontology with
	 *         the specified IRI and no version IRI.
	 */
	@Override
	public OWLOntology getOntology (final IRI ontologyIRI)
	{
		final OWLOntologyID ontologyID = new OWLOntologyID (ontologyIRI);
		return this.getOntology (ontologyID);
	}


	/**
	 * Gets a previously loaded/created ontology that has the specified ontology
	 * ID.
	 * 
	 * @param ontologyID The ID of the ontology to retrieve
	 * @return The ontology that has the specified ID, or <code>null</code> if
	 *         this manager does not manage an ontology with the specified
	 *         ontology ID.
	 */
	@Override
	public OWLOntology getOntology (final OWLOntologyID ontologyID)
	{
		return this.ontologiesByID.get (ontologyID);
	}


	/** {@inheritDoc} */
	@Override
	public Set<OWLOntology> getVersions (final IRI ontology)
	{
		final Set<OWLOntology> onts = new HashSet<OWLOntology> ();
		for (final OWLOntology ont: this.getOntologies ())
		{
			if (ontology.equals (ont.getOntologyID ().getOntologyIRI ()))
				onts.add (ont);
		}
		return onts;
	}


	/**
	 * Given an imports declaration, obtains the ontology that this import has
	 * been resolved to.
	 * 
	 * @param declaration The declaration that points to the imported ontology.
	 * @return The ontology that the imports declaration resolves to, or
	 *         <code>null</code> if the imports declaration could not be resolved
	 *         to an ontology, because the ontology was not loaded or has been
	 *         removed from this manager
	 */
	@Override
	public OWLOntology getImportedOntology (final OWLImportsDeclaration declaration)
	{
		final OWLOntologyID ontologyID = this.ontologyIDsByImportsDeclaration.get (declaration);
		return ontologyID == null ? null : this.getOntology (ontologyID);
	}


	/**
	 * Gets the set of <em>loaded</em> ontologies that the specified ontology is
	 * related to via the directlyImports relation as defined in Section 3.4 of
	 * the OWL 2 Structural specification.
	 * 
	 * @param ontology The ontology whose direct imports are to be retrieved.
	 * @return The set of <em>loaded</em> ontologies that the specified ontology
	 *         is related to via the directlyImports relation.
	 */
	@Override
	public Set<OWLOntology> getDirectImports (final OWLOntology ontology)
	{
		if (!this.contains (ontology))
			throw new UnknownOWLOntologyException (ontology.getOntologyID ());

		final Set<OWLOntology> imports = new HashSet<OWLOntology> ();
		for (final OWLImportsDeclaration axiom: ontology.getImportsDeclarations ())
		{
			final OWLOntology importedOntology = this.getImportedOntology (axiom);
			if (importedOntology != null)
				imports.add (importedOntology);
		}
		return imports;
	}


	/**
	 * Gets the set of ontologies that are in the transitive closure of the
	 * directly imports relation.
	 * 
	 * @param ontology The ontology whose imports are to be retrieved.
	 * @return A set of <code>OWLOntology</code>ies that are in the transitive
	 *         closure of the directly imports relation of this ontology. If, for
	 *         what ever reason, an imported ontology could not be loaded, then it
	 *         will not be contained in the returned set of ontologies.
	 */
	@Override
	public Set<OWLOntology> getImports (final OWLOntology ontology)
	{
		if (!this.contains (ontology))
			throw new UnknownOWLOntologyException (ontology.getOntologyID ());

		final Set<OWLOntology> result = new HashSet<OWLOntology> ();
		this.getImports (ontology, result);
		return result;
	}


	/**
	 * A method that gets the imports of a given ontology.
	 * 
	 * @param ont The ontology whose (transitive) imports are to be retrieved.
	 * @param result A place to store the result - the transitive closure of the
	 *          imports will be stored in this result set.
	 */
	private void getImports (final OWLOntology ont, final Set<OWLOntology> result)
	{
		for (final OWLOntology directImport: this.getDirectImports (ont))
		{
			if (result.add (directImport))
				this.getImports (directImport, result);
		}
	}


	/** {@inheritDoc} */
	@Override
	public Set<OWLOntology> getImportsClosure (final OWLOntology ontology)
	{
		Set<OWLOntology> ontologies = this.importsClosureCache.get (ontology);
		if (ontologies == null)
		{
			ontologies = new HashSet<OWLOntology> ();
			this.getImportsClosure (ontology, ontologies);
			this.importsClosureCache.put (ontology, ontologies);
		}
		return Collections.unmodifiableSet (ontologies);
	}


	/**
	 * A recursive method that gets the reflexive transitive closure of the
	 * ontologies that are imported by this ontology.
	 * 
	 * @param ontology The ontology whose reflexive transitive closure is to be
	 *          retrieved
	 * @param ontologies a place to store the result
	 */
	private void getImportsClosure (final OWLOntology ontology, final Set<OWLOntology> ontologies)
	{
		ontologies.add (ontology);
		for (final OWLOntology ont: this.getDirectImports (ontology))
		{
			if (!ontologies.contains (ont))
				this.getImportsClosure (ont, ontologies);
		}
	}


	/** {@inheritDoc} */
	@Override
	public List<OWLOntology> getSortedImportsClosure (final OWLOntology ontology)
	{
		final List<OWLOntology> importsClosure = new ArrayList<OWLOntology> ();
		this.getSortedImportsClosure (ontology, importsClosure, new HashSet<OWLOntology> ());
		return importsClosure;
	}


	/** {@inheritDoc} */
	@Override
	public List<OWLOntologyChange> applyChanges (final List<? extends OWLOntologyChange> changes)
	{
		try
		{
			this.broadcastImpendingChanges (changes);
		}
		catch (final OWLOntologyChangeVetoException e)
		{
			// Some listener blocked the changes.
			this.broadcastOntologyChangesVetoed (changes, e);
			return Collections.emptyList ();
		}

		final int size = changes.size ();
		final List<OWLOntologyChange> appliedChanges = new ArrayList<OWLOntologyChange> (size + 2);
		this.fireBeginChanges (size);
		for (final OWLOntologyChange change: changes)
		{
			appliedChanges.addAll (this.enactChangeApplication (change));
			this.fireChangeApplied (change);
		}
		this.fireEndChanges ();
		this.broadcastChanges (changes);
		return appliedChanges;
	}


	/** {@inheritDoc} */
	@Override
	public List<OWLOntologyChange> addAxiom (final OWLOntology ont, final OWLAxiom axiom)
	{
		return this.addAxioms (ont, Collections.singleton (axiom));
	}


	/** {@inheritDoc} */
	@Override
	public List<OWLOntologyChange> addAxioms (final OWLOntology ont, final Set<? extends OWLAxiom> axioms)
	{
		final int size = axioms.size ();
		final List<OWLOntologyChange> changes = new ArrayList<OWLOntologyChange> (size);
		// Optimisation - Precheck that the ontology is an immutable ontology.
		if (ont instanceof OWLMutableOntology)
		{
			this.fireBeginChanges (size);
			for (final OWLAxiom ax: axioms)
			{
				// Further optimisation - precheck that the axiom isn't in the
				// ontology.
				if (ont.containsAxiom (ax))
					continue;

				final AddAxiom addAx = new AddAxiom (ont, ax);
				changes.addAll (this.enactChangeApplication (addAx));
				this.fireChangeApplied (addAx);
			}
			this.fireEndChanges ();
		}
		this.broadcastChanges (changes);
		return changes;
	}


	/** {@inheritDoc} */
	@Override
	public List<OWLOntologyChange> removeAxiom (final OWLOntology ont, final OWLAxiom axiom)
	{
		return this.removeAxioms (ont, Collections.singleton (axiom));
	}


	/** {@inheritDoc} */
	@Override
	public List<OWLOntologyChange> removeAxioms (final OWLOntology ont, final Set<? extends OWLAxiom> axioms)
	{
		final int size = axioms.size ();
		final List<OWLOntologyChange> changes = new ArrayList<OWLOntologyChange> (size);
		// Optimisation - Precheck that the ontology is an immutable ontology.
		if (ont instanceof OWLMutableOntology)
		{
			this.fireBeginChanges (size);
			for (final OWLAxiom ax: axioms)
			{
				// Further optimisation - precheck that the axiom is in the
				// ontology.
				if (!ont.containsAxiom (ax))
					continue;

				final RemoveAxiom removeAxiom = new RemoveAxiom (ont, ax);
				changes.addAll (this.enactChangeApplication (removeAxiom));
				this.fireChangeApplied (removeAxiom);
			}
			this.fireEndChanges ();
		}
		this.broadcastChanges (changes);
		return changes;
	}


	/** {@inheritDoc} */
	@Override
	public List<OWLOntologyChange> applyChange (final OWLOntologyChange change)
	{
		this.fireBeginChanges (1);
		final List<OWLOntologyChange> changes = this.enactChangeApplication (change);
		this.fireChangeApplied (change);
		this.fireEndChanges ();
		this.broadcastChanges (changes);
		return changes;
	}


	/**
	 * Check the changes of the imports.
	 * 
	 * @param change The change event
	 */
	private void checkForImportsChange (final OWLOntologyChange change)
	{
		if (change.isImportChange ())
			this.resetImportsClosureCache ();
	}


	/**
	 * Check the changes of ontology ID.
	 * 
	 * @param change the change event
	 */
	private void checkForOntologyIDChange (final OWLOntologyChange change)
	{
		if (change instanceof SetOntologyID)
		{
			final SetOntologyID setURI = (SetOntologyID) change;
			this.renameOntology (setURI.getOriginalOntologyID ());
			this.resetImportsClosureCache ();
		}
	}


	// ///////////////////////////////////////////////////////////////////////////////////////////////////////////
	//
	// Methods to create, load and reload ontologies
	//
	// ///////////////////////////////////////////////////////////////////////////////////////////////////////////

	/** {@inheritDoc} */
	@Override
	public void ontologyCreated (final OWLOntology ontology)
	{
		// This method is called when a factory that we have asked to create or
		// load an ontology has created the ontology. We add the ontology to the
		// set of loaded ontologies.
		this.addOntology (ontology);
	}


	/**
	 * Sets the format of an ontology.
	 * 
	 * @param ontology The ontology
	 * @param format The format of the ontology
	 */
	@Override
	public void setOntologyFormat (final OWLOntology ontology, final OWLOntologyFormat format)
	{
		this.ontologyFormatsByOntology.put (ontology, format);
	}


	/** {@inheritDoc} */
	@Override
	public OWLOntologyFormat getOntologyFormat (final OWLOntology ontology)
	{
		return this.ontologyFormatsByOntology.get (ontology);
	}


	/** {@inheritDoc} */
	@Override
	public OWLOntology createOntology () throws OWLOntologyCreationException
	{
		// Brand new ontology without a URI
		return this.createOntology (new OWLOntologyID ());
	}


	/** {@inheritDoc} */
	@Override
	public OWLOntology createOntology (final IRI ontologyIRI) throws OWLOntologyCreationException
	{
		return this.createOntology (new OWLOntologyID (ontologyIRI));
	}


	/** {@inheritDoc} */
	@Override
	public OWLOntology createOntology (final OWLOntologyID ontologyID) throws OWLOntologyCreationException
	{
		final OWLOntology ontology = this.ontologiesByID.get (ontologyID);
		if (ontology != null)
			return ontology;

		final IRI iri = IRI.create (this.getDocumentURI (ontologyID, false));
		for (final OWLOntologyFactory factory: this.ontologyFactories)
		{
			if (factory.canCreateFromDocumentIRI (iri))
			{
				this.irisByID.put (ontologyID, iri);
				return factory.createOWLOntology (ontologyID, iri, this);
			}
		}
		throw new OWLOntologyFactoryNotFoundException (iri);
	}


	/** {@inheritDoc} */
	@Override
	public OWLOntology createOntology (final IRI ontologyIRI, final Set<OWLOntology> ontologies) throws OWLOntologyCreationException
	{
		return this.createOntology (ontologyIRI, ontologies, false);
	}


	/** {@inheritDoc} */
	@Override
	public OWLOntology createOntology (final IRI ontologyIRI, final Set<OWLOntology> ontologies, final boolean copyLogicalAxiomsOnly) throws OWLOntologyCreationException
	{
		if (this.contains (ontologyIRI))
			throw new OWLOntologyAlreadyExistsException (new OWLOntologyID (ontologyIRI));

		final OWLOntology ont = this.createOntology (ontologyIRI);
		final Set<OWLAxiom> axioms = new HashSet<OWLAxiom> ();
		for (final OWLOntology ontology: ontologies)
		{
			if (copyLogicalAxiomsOnly)
				axioms.addAll (ontology.getLogicalAxioms ());
			else
				axioms.addAll (ontology.getAxioms ());
		}
		this.addAxioms (ont, axioms);
		return ont;
	}


	/** {@inheritDoc} */
	@Override
	public OWLOntology createOntology (final Set<OWLAxiom> axioms, final IRI iri) throws OWLOntologyCreationException
	{
		if (this.contains (iri))
			throw new OWLOntologyAlreadyExistsException (new OWLOntologyID (iri));

		final OWLOntology ont = this.createOntology (iri);
		this.addAxioms (ont, axioms);
		return ont;
	}


	/** {@inheritDoc} */
	@Override
	public OWLOntology createOntology (final Set<OWLAxiom> axioms) throws OWLOntologyCreationException
	{
		return this.createOntology (axioms, this.getNextAutoGeneratedIRI ());
	}


	/**
	 * Create a new ontology in the database according to the input uri and
	 * database properties.
	 * 
	 * @param ontologyID The ID of the ontology
	 * @param props The database properties
	 * @return The DB Ontology object
	 * @throws OWLOntologyCreationException Will be thrown if there is error in
	 *           creation process
	 */
	public OWLOntology createOntology (final OWLOntologyID ontologyID, final Properties props) throws OWLOntologyCreationException
	{
		final OWLOntology ontology = this.ontologiesByID.get (ontologyID);
		if (ontology != null)
			return ontology;

		final IRI iri = IRI.create (this.getDocumentURI (ontologyID, false));
		for (final OWLOntologyFactory factory: this.ontologyFactories)
		{
			if (factory.canCreateFromDocumentIRI (iri))
			{
				this.irisByID.put (ontologyID, iri);
				if (factory instanceof OWLDBOntologyFactory)
					return ((OWLDBOntologyFactory) factory).createOWLOntology (ontologyID, iri, this, props);
				return factory.createOWLOntology (ontologyID, iri, this);
			}
		}
		throw new OWLOntologyFactoryNotFoundException (iri);
	}


	/**
	 * Generates a new IRI bases on a counter.
	 * 
	 * @return An IRI
	 */
	protected IRI getNextAutoGeneratedIRI ()
	{
		this.autoGeneratedURICounter = this.autoGeneratedURICounter + 1;
		return IRI.create ("owlapi:ontology:ont" + this.autoGeneratedURICounter);
	}


	/** {@inheritDoc} */
	@Override
	public OWLOntology loadOntology (final IRI ontologyIRI) throws OWLOntologyCreationException
	{
		final Properties props = new Properties ();
		return this.loadOntology (ontologyIRI, props);
	}


	/** {@inheritDoc} */
	@Override
	public OWLOntology loadOntologyFromOntologyDocument (final IRI documentIRI) throws OWLOntologyCreationException
	{
		return this.loadOntology (documentIRI);
	}


	/**
	 * Load an ontology from database.
	 * 
	 * @param ontologyIRI The physical IRI of the ontology
	 * @param props The database properties
	 * @return The DB Ontology object
	 * @throws OWLOntologyCreationException Will be thrown if there is error in
	 *           loading process
	 */
	public OWLOntology loadOntology (final IRI ontologyIRI, final Properties props) throws OWLOntologyCreationException
	{
		final OWLOntologyID id = new OWLOntologyID (ontologyIRI);

		final OWLOntology ontByID = this.ontologiesByID.get (id);
		if (ontByID != null)
			return ontByID;

		final URI physicalURI = this.getDocumentURI (id, true);
		// The ontology might be being loaded, but its logical URI might
		// not have been set (as is probably the case with RDF/XML!)
		if (physicalURI != null)
		{
			final OWLOntology ontByPhysicalURI = this.getOntology (IRI.create (physicalURI));
			if (ontByPhysicalURI != null)
				return ontByPhysicalURI;
		}
		else
		{
			// Nothing we can do here. We can't get a physical URI to load
			// the ontology from.
			throw new OntologyIRIMappingNotFoundException (ontologyIRI);
		}

		return this.loadOntology (ontologyIRI, new IRIDocumentSource (IRI.create (physicalURI)), props, null);
	}


	/** {@inheritDoc} */
	@Override
	public OWLOntology loadOntologyFromOntologyDocument (final File file) throws OWLOntologyCreationException
	{
		final FileDocumentSource source = new FileDocumentSource (file);
		return this.loadOntology (source.getDocumentIRI (), source, new Properties (), null);
	}


	/** {@inheritDoc} */
	@Override
	public OWLOntology loadOntologyFromOntologyDocument (final InputStream inputStream) throws OWLOntologyCreationException
	{
		final StreamDocumentSource source = new StreamDocumentSource (inputStream);
		return this.loadOntology (source.getDocumentIRI (), source, new Properties (), null);
	}


	/** {@inheritDoc} */
	@Override
	public OWLOntology loadOntologyFromOntologyDocument (final OWLOntologyDocumentSource documentSource) throws OWLOntologyCreationException
	{
		return this.loadOntology (documentSource.getDocumentIRI (), documentSource, new Properties (), null);
	}


	/** {@inheritDoc} */
	@Override
	public OWLOntology loadOntologyFromOntologyDocument (final OWLOntologyDocumentSource documentSource, final OWLOntologyLoaderConfiguration config) throws OWLOntologyCreationException
	{
		return this.loadOntology (documentSource.getDocumentIRI (), documentSource, new Properties (), config);
	}


	/**
	 * This is the method that all the other load method delegate to.
	 * 
	 * @param ontologyIRI The IRI of the ontology to be loaded. This is only used
	 *          to report to listeners and may be <code>null</code>
	 * @param inputSource The input source that specifies where the ontology
	 *          should be loaded from.
	 * @param props The database properties
	 * @param configuration Configuration for the loader
	 * @return The ontology that was loaded.
	 * @throws OWLOntologyCreationException If the ontology could not be loaded.
	 */
	protected OWLOntology loadOntology (final IRI ontologyIRI, final OWLOntologyDocumentSource inputSource, final Properties props, final OWLOntologyLoaderConfiguration configuration) throws OWLOntologyCreationException
	{
		if (this.loadCount != this.importsLoadCount)
			System.err.println ("Runtime Warning: Parsers should load imported ontologies using the makeImportLoadRequest method.");

		final IRI documentIRI = inputSource.getDocumentIRI ();
		this.fireStartedLoadingEvent (new OWLOntologyID (ontologyIRI), documentIRI, this.loadCount > 0);
		this.loadCount++;
		this.broadcastChanges = false;
		final OWLOntologyFactory factory = this.getLoadFactoryFor (inputSource);
		if (factory == null)
			throw new OWLOntologyFactoryNotFoundException (documentIRI);

		OWLOntologyCreationException ex = null;
		OWLOntologyID idOfLoadedOntology = new OWLOntologyID ();

		try
		{
			// Note - there is no need to add the ontology here, because it will
			// be added when the ontology is created.
			OWLOntology ontology;
			if (factory instanceof OWLDBOntologyFactory)
				ontology = ((OWLDBOntologyFactory) factory).loadOWLOntology (inputSource, this, props);
			else
				ontology = factory.loadOWLOntology (inputSource, this, configuration == null ? new OWLOntologyLoaderConfiguration () : configuration);
			idOfLoadedOntology = ontology.getOntologyID ();
			// Store the ontology to physical URI mapping
			this.irisByID.put (idOfLoadedOntology, documentIRI);
			return ontology;
		}
		catch (final OWLOntologyCreationException e)
		{
			ex = e;
			throw e;
		}
		finally
		{
			this.loadCount--;
			if (this.loadCount == 0)
			{
				this.broadcastChanges = true;
				// Completed loading ontology and imports
			}
			this.fireFinishedLoadingEvent (idOfLoadedOntology, documentIRI, this.loadCount > 0, ex);
		}
	}


	/** {@inheritDoc} */
	@Override
	public void removeOntology (final OWLOntology ontology)
	{
		final OWLOntologyID ontologyID = ontology.getOntologyID ();
		this.ontologiesByID.remove (ontologyID);
		this.ontologyFormatsByOntology.remove (ontology);
		this.irisByID.remove (ontologyID);
		for (final Iterator<OWLImportsDeclaration> it = this.ontologyIDsByImportsDeclaration.keySet ().iterator (); it.hasNext ();)
		{
			if (this.ontologyIDsByImportsDeclaration.get (it.next ()).equals (ontologyID))
				it.remove ();
		}
		this.resetImportsClosureCache ();

		// TODO The ontology needs to be deleted from the database!!!
	}


	/**
	 * Add an ontology to the manager.
	 * 
	 * @param ont The ontology to add
	 */
	private void addOntology (final OWLOntology ont)
	{
		this.ontologiesByID.put (ont.getOntologyID (), ont);
	}


	/** {@inheritDoc} */
	@Override
	public IRI getOntologyDocumentIRI (final OWLOntology ontology)
	{
		final OWLOntologyID ontologyID = ontology.getOntologyID ();
		if (!this.contains (ontology))
			throw new UnknownOWLOntologyException (ontologyID);

		return this.irisByID.get (ontologyID);
	}


	/** {@inheritDoc} */
	@Override
	public void setOntologyDocumentIRI (final OWLOntology ontology, final IRI documentIRI)
	{
		final OWLOntologyID ontologyID = ontology.getOntologyID ();
		if (!this.ontologiesByID.containsKey (ontologyID))
			throw new UnknownOWLOntologyException (ontologyID);

		this.irisByID.put (ontologyID, documentIRI);
	}


	/**
	 * Handles a rename of an ontology. This method should only be called *after*
	 * the change has been applied
	 * 
	 * @param oldID The original ID of the ontology
	 */
	private void renameOntology (final OWLOntologyID oldID)
	{
		final OWLOntology ont = this.ontologiesByID.get (oldID);
		if (ont == null) // Nothing to rename!
			return;
		this.ontologiesByID.remove (oldID);
		final OWLOntologyID ontologyID = ont.getOntologyID ();
		this.ontologiesByID.put (ontologyID, ont);
		final IRI iri = this.irisByID.remove (oldID);
		this.irisByID.put (ontologyID, iri);
		this.resetImportsClosureCache ();
	}


	/**
	 * Clear the import closure cache.
	 */
	private void resetImportsClosureCache ()
	{
		this.importsClosureCache.clear ();
	}


	// /////////////////////////////////////////////////////////////////////////////////////////////////////////
	//
	// Methods to save ontologies
	//
	// /////////////////////////////////////////////////////////////////////////////////////////////////////////

	/** {@inheritDoc} */
	@Override
	public void saveOntology (final OWLOntology ontology) throws OWLOntologyStorageException
	{
		this.saveOntology (ontology, this.getOntologyFormat (ontology));
	}


	/** {@inheritDoc} */
	@Override
	public void saveOntology (final OWLOntology ontology, final OWLOntologyFormat ontologyFormat) throws OWLOntologyStorageException
	{
		this.saveOntology (ontology, ontologyFormat, this.getOntologyDocumentIRI (ontology));
	}


	/** {@inheritDoc} */
	@Override
	public void saveOntology (final OWLOntology ontology, final IRI documentIRI) throws OWLOntologyStorageException
	{
		this.saveOntology (ontology, this.getOntologyFormat (ontology), documentIRI);
	}


	/** {@inheritDoc} */
	@Override
	public void saveOntology (final OWLOntology ontology, final OWLOntologyFormat ontologyFormat, final IRI documentIRI) throws OWLOntologyStorageException
	{
		try
		{
			this.getStorerFor (ontologyFormat).storeOntology (this, ontology, documentIRI, ontologyFormat);
		}
		catch (final IOException ex)
		{
			throw new OWLOntologyStorageIOException (ex);
		}
	}


	/** {@inheritDoc} */
	@Override
	public void saveOntology (final OWLOntology ontology, final OWLOntologyDocumentTarget documentTarget) throws OWLOntologyStorageException
	{
		this.saveOntology (ontology, this.getOntologyFormat (ontology), documentTarget);
	}


	/** {@inheritDoc} */
	@Override
	public void saveOntology (final OWLOntology ontology, final OutputStream outputStream) throws OWLOntologyStorageException
	{
		this.saveOntology (ontology, this.getOntologyFormat (ontology), outputStream);
	}


	/** {@inheritDoc} */
	@Override
	public void saveOntology (final OWLOntology ontology, final OWLOntologyFormat ontologyFormat, final OutputStream outputStream) throws OWLOntologyStorageException
	{
		this.saveOntology (ontology, ontologyFormat, new StreamDocumentTarget (outputStream));
	}


	/** {@inheritDoc} */
	@Override
	public void saveOntology (final OWLOntology ontology, final OWLOntologyFormat ontologyFormat, final OWLOntologyDocumentTarget documentTarget) throws OWLOntologyStorageException
	{
		try
		{
			this.getStorerFor (ontologyFormat).storeOntology (this, ontology, documentTarget, ontologyFormat);
		}
		catch (final IOException ex)
		{
			throw new OWLOntologyStorageIOException (ex);
		}
	}


	/**
	 * Save the ontology into a database.
	 * 
	 * @param ontology the to be saved ontology
	 * @param targetIRI the target IRI
	 * @param props the properties of the database
	 * @throws OWLOntologyCreationException will be thrown if there is error
	 *           during saving to database
	 */
	public void saveOntologyToDB (final OWLOntology ontology, final IRI targetIRI, final Properties props) throws OWLOntologyCreationException
	{
		final OWLOntologyID ontologyID = new OWLOntologyID (targetIRI);
		final OWLOntology newOnto = this.createOntology (ontologyID, props);
		((OWLMutableOntology) newOnto).applyChange (new SetOntologyID (newOnto, ontology.getOntologyID ()));
		final Set<OWLAxiom> axioms = ontology.getAxioms ();
		this.addAxioms (newOnto, axioms);
	}


	/**
	 * Save the ontology in OWLDB format.
	 * 
	 * @param ontology The to be saved ontology
	 * @param ontologyFormat The ontology format
	 * @param targetIRI The target IRI
	 * @param props The properties of the database
	 * @throws OWLOntologyCreationException Will be thrown if there is error
	 *           during creating ontology in database
	 * @throws OWLOntologyStorageException Will be thrown if there is error during
	 *           saving to database
	 */
	public void saveOntology (final OWLOntology ontology, final OWLOntologyFormat ontologyFormat, final IRI targetIRI, final Properties props) throws OWLOntologyCreationException, OWLOntologyStorageException
	{
		final OWLOntologyStorer storer = this.getStorerFor (ontologyFormat);
		// Note: This should be not necessary but the OWL API does not provide this
		// function so far
		if (storer instanceof OWLDBStorer)
			((OWLDBStorer) storer).storeOntology (this, ontology, targetIRI, props, ontologyFormat);
	}


	// /////////////////////////////////////////////////////////////////////////////////////////////////////////
	//
	// Methods to add/remove ontology storers
	//
	// /////////////////////////////////////////////////////////////////////////////////////////////////////////

	/** {@inheritDoc} */
	@Override
	public void addOntologyStorer (final OWLOntologyStorer storer)
	{
		this.ontologyStorers.add (0, storer);
	}


	/** {@inheritDoc} */
	@Override
	public void removeOntologyStorer (final OWLOntologyStorer storer)
	{
		this.ontologyStorers.remove (storer);
	}


	// /////////////////////////////////////////////////////////////////////////////////////////////////////////
	//
	// Methods to add/remove mappers etc.
	//
	// /////////////////////////////////////////////////////////////////////////////////////////////////////////

	/** {@inheritDoc} */
	@Override
	public final void addIRIMapper (final OWLOntologyIRIMapper mapper)
	{
		this.documentMappers.add (0, mapper);
	}


	/** {@inheritDoc} */
	@Override
	public void clearIRIMappers ()
	{
		this.documentMappers.clear ();
	}


	/** {@inheritDoc} */
	@Override
	public void removeIRIMapper (final OWLOntologyIRIMapper mapper)
	{
		this.documentMappers.remove (mapper);
	}


	/** {@inheritDoc} */
	@Override
	public void addOntologyFactory (final OWLOntologyFactory factory)
	{
		this.ontologyFactories.add (0, factory);
		factory.setOWLOntologyManager (this);
	}


	/** {@inheritDoc} */
	@Override
	public void removeOntologyFactory (final OWLOntologyFactory factory)
	{
		this.ontologyFactories.remove (factory);
	}


	/**
	 * Uses the mapper mechanism to obtain a physical URI for an ontology URI.
	 * 
	 * @param ontologyID The ontology ID for which the physical mapping is to be
	 *          retrieved
	 * @param quiet If set to <code>true</code> and a mapping can't be found then
	 *          a value of <code>null</code> is returned. If set to
	 *          <code>false</code> and a mapping can't be found then an exception
	 *          OWLOntologyURIMappingNotFoundException is thrown.
	 * @return The physical URI that corresponds to the ontology URI, or
	 *         <code>null</code> if no physical URI can be found.
	 */
	private URI getDocumentURI (final OWLOntologyID ontologyID, final boolean quiet)
	{
		final IRI defIRI = ontologyID.getDefaultDocumentIRI ();
		if (defIRI == null)
			return null;

		for (final OWLOntologyIRIMapper mapper: this.documentMappers)
		{
			final IRI iri = mapper.getDocumentIRI (defIRI);
			if (iri != null)
				return iri.toURI ();
		}

		if (!quiet)
			throw new OWLOntologyIRIMappingNotFoundException (defIRI);

		return null;
	}


	/**
	 * Install the default URI mappers. By defaut install the default mapper that
	 * simply maps ontology URIs to themselves.
	 */
	private void installDefaultURIMappers ()
	{
		this.addIRIMapper (new NonMappingOntologyIRIMapper ());
	}


	/**
	 * Installs the default ontology factories. The default factories are the ones
	 * that can load ontologies from http:// and file:// URIs
	 */
	private void installDefaultOntologyFactories ()
	{
		// Empty by intention
	}

	// //////////////////////////////////////////////////////////////////////////////////////////////////
	//
	// Listener stuff - methods to add/remove listeners
	//
	// //////////////////////////////////////////////////////////////////////////////////////////////////

	private final Map<OWLOntologyChangeListener, OWLOntologyChangeBroadcastStrategy>	listenerMap	= new LinkedHashMap<OWLOntologyChangeListener, OWLOntologyChangeBroadcastStrategy> ();


	/** {@inheritDoc} */
	@Override
	public void addOntologyChangeListener (final OWLOntologyChangeListener listener)
	{
		this.listenerMap.put (listener, this.defaultChangeBroadcastStrategy);
	}


	/**
	 * Broadcasts to attached listeners, using the various broadcasting strategies
	 * that were specified for each listener.
	 * 
	 * @param changes The ontology changes to broadcast
	 */
	private void broadcastChanges (final List<? extends OWLOntologyChange> changes)
	{
		if (!this.broadcastChanges)
		{
			return;
		}
		for (final OWLOntologyChangeListener listener: new ArrayList<OWLOntologyChangeListener> (this.listenerMap.keySet ()))
		{
			final OWLOntologyChangeBroadcastStrategy strategy = this.listenerMap.get (listener);
			if (strategy == null)
			{
				// This listener may have been removed during the broadcast of
				// the
				// changes, so when we attempt to retrieve it from the map it
				// isn't
				// there (because we iterate over a copy).
				continue;
			}
			try
			{
				// Handle exceptions on a per listener basis. If we have badly
				// behaving
				// listeners, we don't want one listener to prevent the other
				// listeners
				// from receiving events.
				strategy.broadcastChanges (listener, changes);
			}
			catch (final Throwable e)
			{
				LOGGER.warning ("BADLY BEHAVING LISTENER: " + e);
				e.printStackTrace ();
			}
		}
	}


	/** {@inheritDoc} */
	@Override
	public void setDefaultChangeBroadcastStrategy (final OWLOntologyChangeBroadcastStrategy strategy)
	{
		this.defaultChangeBroadcastStrategy = strategy != null ? strategy : new DefaultChangeBroadcastStrategy ();
	}


	/** {@inheritDoc} */
	@Override
	public void addOntologyChangeListener (final OWLOntologyChangeListener listener, final OWLOntologyChangeBroadcastStrategy strategy)
	{
		this.listenerMap.put (listener, strategy);
	}


	/** {@inheritDoc} */
	@Override
	public void removeOntologyChangeListener (final OWLOntologyChangeListener listener)
	{
		this.listenerMap.remove (listener);
	}


	/** {@inheritDoc} */
	@SuppressWarnings("deprecation")
	@Deprecated
	@Override
	public void makeLoadImportRequest (final OWLImportsDeclaration declaration) throws UnloadableImportException
	{
		this.makeLoadImportRequest (declaration, new OWLOntologyLoaderConfiguration ());
	}


	/** {@inheritDoc} */
	@Override
	public void makeLoadImportRequest (final OWLImportsDeclaration declaration, final OWLOntologyLoaderConfiguration configuration) throws UnloadableImportException
	{
		if (configuration.isIgnoredImport (declaration.getIRI ()))
			return;

		try
		{
			final OWLOntology ont = this.loadImports (declaration, configuration);
			if (ont != null)
				this.ontologyIDsByImportsDeclaration.put (declaration, ont.getOntologyID ());
		}
		catch (final OWLOntologyCreationException e)
		{
			// Wrap as UnloadableImportException and throw
			throw new UnloadableImportException (e, declaration);
		}
	}


	/** {@inheritDoc} */
	@SuppressWarnings("deprecation")
	@Override
	public void setSilentMissingImportsHandling (final boolean b)
	{
		this.silentMissingImportsHandling = b;
	}


	/** {@inheritDoc} */
	@SuppressWarnings("deprecation")
	@Override
	public boolean isSilentMissingImportsHandling ()
	{
		return this.silentMissingImportsHandling;
	}


	/** {@inheritDoc} */
	@Override
	public void addMissingImportListener (final MissingImportListener listener)
	{
		this.missingImportsListeners.add (listener);
	}


	/** {@inheritDoc} */
	@Override
	public void removeMissingImportListener (final MissingImportListener listener)
	{
		this.missingImportsListeners.remove (listener);
	}


	/**
	 * Fires a missing import event to all listeners.
	 * 
	 * @param evt The event to fire
	 */
	protected void fireMissingImportEvent (final MissingImportEvent evt)
	{
		for (final MissingImportListener listener: new ArrayList<MissingImportListener> (this.missingImportsListeners))
			listener.importMissing (evt);
	}


	// //////////////////////////////////////////////////////////////////////////////////////////////////////////
	//
	// Other listeners etc.
	//
	// //////////////////////////////////////////////////////////////////////////////////////////////////////////

	/** {@inheritDoc} */
	@Override
	public void addOntologyLoaderListener (final OWLOntologyLoaderListener listener)
	{
		this.loaderListeners.add (listener);
	}


	/** {@inheritDoc} */
	@Override
	public void removeOntologyLoaderListener (final OWLOntologyLoaderListener listener)
	{
		this.loaderListeners.remove (listener);
	}


	/**
	 * Fires a started loading event.
	 * 
	 * @param ontologyID The ID of the ontology which started loading
	 * @param iri The IRI of the ontology
	 * @param imported True if it is an imported ontology
	 */
	protected void fireStartedLoadingEvent (final OWLOntologyID ontologyID, final IRI iri, final boolean imported)
	{
		for (final OWLOntologyLoaderListener listener: new ArrayList<OWLOntologyLoaderListener> (this.loaderListeners))
			listener.startedLoadingOntology (new OWLOntologyLoaderListener.LoadingStartedEvent (ontologyID, iri, imported));
	}


	/**
	 * Fires a finished loading event.
	 * 
	 * @param ontologyID The ID of the ontology which started loading
	 * @param iri The IRI of the ontology
	 * @param imported True if it is an imported ontology
	 * @param ex The exception that may have occured during the load process
	 */
	protected void fireFinishedLoadingEvent (final OWLOntologyID ontologyID, final IRI iri, final boolean imported, final OWLOntologyCreationException ex)
	{
		for (final OWLOntologyLoaderListener listener: new ArrayList<OWLOntologyLoaderListener> (this.loaderListeners))
			listener.finishedLoadingOntology (new OWLOntologyLoaderListener.LoadingFinishedEvent (ontologyID, iri, imported, ex));
	}


	/** {@inheritDoc} */
	@Override
	public void addOntologyChangeProgessListener (final OWLOntologyChangeProgressListener listener)
	{
		this.progressListeners.add (listener);
	}


	/** {@inheritDoc} */
	@Override
	public void removeOntologyChangeProgessListener (final OWLOntologyChangeProgressListener listener)
	{
		this.progressListeners.remove (listener);
	}


	/** {@inheritDoc} */
	@Override
	public void addImpendingOntologyChangeListener (final ImpendingOWLOntologyChangeListener listener)
	{
		this.impendingChangeListenerMap.put (listener, this.defaultImpendingChangeBroadcastStrategy);
	}


	/** {@inheritDoc} */
	@Override
	public void removeImpendingOntologyChangeListener (final ImpendingOWLOntologyChangeListener listener)
	{
		this.impendingChangeListenerMap.remove (listener);
	}


	/**
	 * Broadcast the changes.
	 * 
	 * @param changes The changes
	 */
	private void broadcastImpendingChanges (final List<? extends OWLOntologyChange> changes)
	{
		if (!this.broadcastChanges)
			return;

		for (final ImpendingOWLOntologyChangeListener listener: new ArrayList<ImpendingOWLOntologyChangeListener> (this.impendingChangeListenerMap.keySet ()))
		{
			final ImpendingOWLOntologyChangeBroadcastStrategy strategy = this.impendingChangeListenerMap.get (listener);
			if (strategy != null)
			{
				strategy.broadcastChanges (listener, changes);
			}
		}
	}


	/** {@inheritDoc} */
	@Override
	public void addOntologyChangesVetoedListener (final OWLOntologyChangesVetoedListener listener)
	{
		this.vetoListeners.add (listener);
	}


	/** {@inheritDoc} */
	@Override
	public void removeOntologyChangesVetoedListener (final OWLOntologyChangesVetoedListener listener)
	{
		this.vetoListeners.remove (listener);
	}


	/**
	 * Broadcast vetoed changes.
	 * 
	 * @param changes The changes
	 * @param veto The veto
	 */
	private void broadcastOntologyChangesVetoed (final List<? extends OWLOntologyChange> changes, final OWLOntologyChangeVetoException veto)
	{
		for (final OWLOntologyChangesVetoedListener listener: new ArrayList<OWLOntologyChangesVetoedListener> (this.vetoListeners))
			listener.ontologyChangesVetoed (changes, veto);
	}


	/**
	 * Fires a change begin event.
	 * 
	 * @param size The number of changes
	 */
	protected void fireBeginChanges (final int size)
	{
		try
		{
			if (!this.broadcastChanges)
				return;

			for (final OWLOntologyChangeProgressListener lsnr: this.progressListeners)
				lsnr.begin (size);
		}
		catch (final Throwable e)
		{
			e.printStackTrace ();
		}
	}


	/**
	 * Fires and change end event.
	 */
	protected void fireEndChanges ()
	{
		try
		{
			if (!this.broadcastChanges)
				return;

			for (final OWLOntologyChangeProgressListener lsnr: this.progressListeners)
				lsnr.end ();
		}
		catch (final Throwable e)
		{
			// Listener threw an exception
			e.printStackTrace ();
		}
	}


	/**
	 * Fire an applied change event.
	 * 
	 * @param change The change
	 */
	protected void fireChangeApplied (final OWLOntologyChange change)
	{
		try
		{
			if (!this.broadcastChanges)
				return;

			for (final OWLOntologyChangeProgressListener lsnr: this.progressListeners)
				lsnr.appliedChange (change);
		}
		catch (final Throwable e)
		{
			// Listener threw an exception
			e.printStackTrace ();
		}
	}


	/**
	 * Get a factory which can load the given input source.
	 * 
	 * @param inputSource The input source to load
	 * @return The factory or null
	 */
	protected OWLOntologyFactory getLoadFactoryFor (final OWLOntologyDocumentSource inputSource)
	{
		for (final OWLOntologyFactory factory: this.ontologyFactories)
		{
			if (factory.canLoad (inputSource))
				return factory;
		}
		return null;
	}


	/**
	 * Get a storer which can handle the given ontology format.
	 * 
	 * @param ontologyFormat How to format the ontology
	 * @return The matching storer
	 * @throws OWLOntologyStorerNotFoundException If matching storer could be
	 *           found
	 */
	protected OWLOntologyStorer getStorerFor (final OWLOntologyFormat ontologyFormat) throws OWLOntologyStorerNotFoundException
	{
		for (final OWLOntologyStorer storer: this.ontologyStorers)
		{
			if (storer.canStoreOntology (ontologyFormat))
				return storer;
		}
		throw new OWLOntologyStorerNotFoundException (ontologyFormat);
	}


	/**
	 * Loads the ontology from the given imports declaration.
	 * 
	 * @param declaration An imports declaration
	 * @param configuration Configuration for the loader
	 * @return The loaded ontology
	 * @throws OWLOntologyCreationException Could not create the ontology
	 */
	private OWLOntology loadImports (final OWLImportsDeclaration declaration, final OWLOntologyLoaderConfiguration configuration) throws OWLOntologyCreationException
	{
		this.importsLoadCount++;
		OWLOntology ont = null;
		try
		{
			ont = this.loadOntology (declaration.getIRI ());
		}
		catch (final OWLOntologyCreationException e)
		{
			if (!this.silentMissingImportsHandling)
				throw e;

			// Silent
			this.fireMissingImportEvent (new MissingImportEvent (declaration.getIRI(), e));
		}
		finally
		{
			this.importsLoadCount--;
		}
		return ont;
	}


	/**
	 * Get a sorted imports closure.
	 * 
	 * @param ontology The main ontology
	 * @param imports The imports of the ontoloy
	 * @param marker Mark already handled ontologies
	 */
	private void getSortedImportsClosure (final OWLOntology ontology, final List<OWLOntology> imports, final Set<OWLOntology> marker)
	{
		if (marker.contains (ontology))
			return;

		imports.add (ontology);
		marker.add (ontology);
		for (final OWLOntology imported: this.getDirectImports (ontology))
			this.getSortedImportsClosure (imported, imports, marker);
	}


	/**
	 * Determines if a change is applicable. A change may not be applicable for a
	 * number of reasons.
	 * 
	 * @param change The change to be tested.
	 * @return <code>true</code> if the change is applicable, otherwise,
	 *         <code>false</code>.
	 */
	private boolean isChangeApplicable (final OWLOntologyChange change)
	{
		if (!this.getProperties ().isLoadAnnotationAxioms () && change instanceof AddAxiom)
		{
			if (change.getAxiom () instanceof OWLAnnotationAxiom)
				return false;
		}
		return true;
	}


	/**
	 * Applies a change to an ontology and performs the necessary housekeeping
	 * tasks.
	 * 
	 * @param change The change to be applied.
	 * @return A list of changes that were actually applied.
	 * @throws OWLOntologyChangeException
	 */
	private List<OWLOntologyChange> enactChangeApplication (final OWLOntologyChange change)
	{
		if (!this.isChangeApplicable (change))
			return Collections.emptyList ();

		final OWLOntology ont = change.getOntology ();
		if (!(ont instanceof OWLMutableOntology))
			throw new ImmutableOWLOntologyChangeException (change);

		final List<OWLOntologyChange> appliedChanges = ((OWLMutableOntology) ont).applyChange (change);
		this.checkForOntologyIDChange (change);
		this.checkForImportsChange (change);
		return appliedChanges;
	}
}
